<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface Definition · AtomsCalculators.jl</title><meta name="title" content="Interface Definition · AtomsCalculators.jl"/><meta property="og:title" content="Interface Definition · AtomsCalculators.jl"/><meta property="twitter:title" content="Interface Definition · AtomsCalculators.jl"/><meta name="description" content="Documentation for AtomsCalculators.jl."/><meta property="og:description" content="Documentation for AtomsCalculators.jl."/><meta property="twitter:description" content="Documentation for AtomsCalculators.jl."/><meta property="og:url" content="https://JuliaMolSim.github.io/AtomsCalculators.jl/interface-definition/"/><meta property="twitter:url" content="https://JuliaMolSim.github.io/AtomsCalculators.jl/interface-definition/"/><link rel="canonical" href="https://JuliaMolSim.github.io/AtomsCalculators.jl/interface-definition/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AtomsCalculators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Interface Definition</a><ul class="internal"><li><a class="tocitem" href="#Output"><span>Output</span></a></li><li><a class="tocitem" href="#Implementing-the-interface"><span>Implementing the interface</span></a></li><li><a class="tocitem" href="#Other-Automatically-Generated-Calls"><span>Other Automatically Generated Calls</span></a></li><li><a class="tocitem" href="#Testing-Function-Calls"><span>Testing Function Calls</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface Definition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface Definition</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/AtomsCalculators.jl/blob/master/docs/src/interface-definition.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface-Definition"><a class="docs-heading-anchor" href="#Interface-Definition">Interface Definition</a><a id="Interface-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-Definition" title="Permalink"></a></h1><p>There are two alternative ways to call the interface: using functions <code>potential_energy</code>, <code>forces</code> and <a href="https://en.wikipedia.org/wiki/Virial_stress">virial</a>, or using <code>calculate</code> function together with <code>Energy</code>, <code>Forces</code> and <code>Virial</code>.</p><p>Individual calls are implemented by dispatching <code>AtomsCalculators</code> functions</p><ul><li><code>AtomsCalculators.potential_energy</code> for potential energy calculation</li><li><code>AtomsCalculators.forces</code> for allocating force calculation and/or...</li><li><code>AtomsCalculators.forces!</code> for non-allocating force calculation</li><li><code>AtomsCalculators.virial</code> for <a href="https://en.wikipedia.org/wiki/Virial_stress">virial</a> calculation</li></ul><p>The <code>calculate</code> interface is implemented by dispatching to</p><ul><li><code>AtomsCalculators.calculate</code> using <code>AtomsCalculators.Energy()</code> as the first argument for energy calculation</li><li><code>AtomsCalculators.calculate</code> using <code>AtomsCalculators.Forces()</code> as the first argument for forces calculaton</li><li><code>AtomsCalculators.calculate</code> using <code>AtomsCalculators.Virial()</code> as the first argument for virial calculation</li></ul><p>You do not need to implement all of these by yourself. There is macro that will help implement the other calls. </p><p>Each of the individual calls have two common inputs: <code>AtomsBase.AbstractSystem</code> compatible structure and a <code>calculator</code> that incudes details of the calculation method. Calculate interface has additionally the type of calculation as the first input. You can tune calculation by passing keyword arguments, which can be ignored, but they need to be present in the function definition.</p><p><code>potential_energy</code>, <code>forces</code>, <code>forces!</code> and <code>virial</code>:</p><ul><li>First input is <code>AtomsBase.AbstractSystem</code> compatible structure</li><li>Second input is <code>calculator</code> structure</li><li>Method has to accept keyword arguments (they can be ignored)</li><li>Non-allocating force call <code>force!</code> has an AbstractVector as the first input, to which the evaluated force values are stored (look for more details below)</li></ul><p><code>calculate</code>:</p><ul><li>First input is either <code>Energy()</code>, <code>Forces()</code> or <code>Virial()</code></li><li>Second is <code>AtomsBase.AbstractSystem</code> compatible structure</li><li>Third is <code>calculator</code> structure</li><li>Method has to accept keyword arguments (they can be ignored)</li></ul><h2 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h2><p>Outputs for the functions need to have following properties</p><ul><li>Energy is a subtype of <code>Number</code> that has a unit with dimensions of energy (mass * length^2 / time^2)</li><li>Force output is a subtype of <code>AbstractVector</code> with element type also a subtype of AbstractVector (length 3 in 3D) and unit with dimensions of force (mass * length / time^2). With additional property that it can be reinterpret as a matrix</li><li>Virial is a square matrix (3x3 in 3D) that has units of force times length or energy</li><li>Calculate methods return a <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a> that uses keys <code>:energy</code>, <code>:forces</code> and <code>:virial</code> to identify the results, which have the types defined above</li></ul><h2 id="Implementing-the-interface"><a class="docs-heading-anchor" href="#Implementing-the-interface">Implementing the interface</a><a id="Implementing-the-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-interface" title="Permalink"></a></h2><p>You can either implement both of the calls e.g. for energy</p><p><code>AtomsCalculators.potential_energy(system, calculator; kwargs...)</code> and <code>AtomsCalculators(AtomsCalculators.Energy(), system, calculator; kwargs...)</code></p><h3 id="Example-implementations"><a class="docs-heading-anchor" href="#Example-implementations">Example implementations</a><a id="Example-implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-implementations" title="Permalink"></a></h3><p>Example <code>potential_energy</code> implementation</p><pre><code class="language-julia hljs">using AtomsCalculators
using Unitful
struct MyType
end

AtomsCalculators.@generate_interface function AtomsCalculators.potential_energy(system, calculator::Main.MyType; kwargs...)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition here
    return 0.0u&quot;eV&quot;
end</code></pre><div class="admonition is-info"><header class="admonition-header">Type definition under @generate_complement macro</header><div class="admonition-body"><p>You need to use explicit definition of type when using <code>@generate_interface</code> macro. <code>Main.MyType</code> is fine <code>MyType</code> is not!</p><p>You also need to define the type before the macro call.</p></div></div><p>Completely equivalent implementation is</p><pre><code class="language-julia hljs">AtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Energy, system, calculator::Main.MyType; kwargs...)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition here
    return ( energy = 0.0u&quot;eV, )
end</code></pre><p>Example <code>virial</code> implementation</p><pre><code class="language-julia hljs">AtomsCalculators.@generate_interface function AtomsCalculators.virial(system, calculator::Main.MyType; kwargs...)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition here
    return zeros(3,3) * u&quot;eV&quot;
end</code></pre><p>Equivalent implementation is</p><pre><code class="language-julia hljs">AtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Virial, system, calculator::Main.MyType; kwargs...)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition here
    return ( virial = zeros(3,3) * u&quot;eV&quot;, )
end</code></pre><h3 id="Implementing-forces-call"><a class="docs-heading-anchor" href="#Implementing-forces-call">Implementing forces call</a><a id="Implementing-forces-call-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-forces-call" title="Permalink"></a></h3><p>Basic example</p><pre><code class="language-julia hljs">AtomsCalculators.@generate_interface function AtomsCalculators.forces(system, calculator::Main.MyType; kwargs...)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition
    return AtomsCalculators.zero_forces(system, calculator)
end</code></pre><p>This creates both <code>forces</code> and <code>forces!</code> and <code>calculate</code> command with <code>Forces()</code> support.</p><p><code>AtomsCalculators.zero_forces(system, calculator)</code> is a function that creates zero forces for a given calculator and system combo. You can use this function to tune your force output.</p><p>Same way <code>AtomsCalculators.promote_force_type(system, calculator)</code> creates a force type for the calculator for given input that can be used to allocate force data. You can also allocate for some other type, of your choosing or use the default one. You can overload <code>promote_force_type</code> for your force type, this is automatically used by <code>zero_forces</code> command to change the element type. If you wan to change array type overload <code>zero_forces</code> for your calculator.</p><p>Alternatively the definition could have been done with</p><pre><code class="language-julia hljs">AtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Forces, system, calculator::Main.MyType; kwargs...)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition
    return ( forces = zeros(AtomsCalculators.promote_force_type(system, calculator), length(system)), )
end</code></pre><p>or with non-allocating forces</p><pre><code class="language-julia hljs">struct MyOtherType
end

AtomsCalculators.@generate_interface function AtomsCalculators.forces!(f::AbstractVector, system, calculator::Main.MyOtherType; kwargs...)
    @assert length(f) == length(system)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition
    for i in eachindex(f)
        f[i] = zero(AtomsCalculators.promote_force_type(system, calculator))
    end

    return f
end</code></pre><h2 id="Other-Automatically-Generated-Calls"><a class="docs-heading-anchor" href="#Other-Automatically-Generated-Calls">Other Automatically Generated Calls</a><a id="Other-Automatically-Generated-Calls-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Automatically-Generated-Calls" title="Permalink"></a></h2><p>Many methods have optimized calls when energy and forces (and/or virial) are calculated together. To allow access to these calls there are also calls</p><ul><li><code>energy_forces</code> for potential energy and allocating forces</li><li><code>energy_forces!</code> for potential energy and non-allocating forces</li><li><code>energy_forces_virial</code> for potential energy, allocating forces and virial</li><li><code>energy_forces_virial!</code> for potential energy, non-allocating forces and virial</li></ul><p>These all are generated automatically, if you have defined the corresponding individual methods. The main idea here is that you can implement more efficient methods by yourself.</p><p>Example implementation</p><pre><code class="language-julia hljs">function AtomsCalculators.potential_energy_forces(system, calculator::MyType; kwargs...)
    # we can ignore kwargs... or use them to tune the calculation
    # or give extra information like pairlist

    # add your own definition here
    E = 0.0u&quot;eV&quot;
    f = zeros(AtomsCalculators.default_force_eltype, length(system))
    return (;
        :energy =&gt; E,
        :forces =&gt; f
    )
end</code></pre><p>Defining this does not overload the corresponding non-allocating call - you need to do that separately.</p><p>Output for the combination methods is defined to have keys <code>:energy</code>, <code>:forces</code> and <code>:virial</code>. You can access them with</p><ul><li><code>output[:energy]</code> for energy</li><li><code>output[:forces]</code> for forces</li><li><code>output[:virial]</code> for viral</li></ul><p>The type of the output can be <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a>, as was in the example above, or any structure that has the keys implemented and also supports splatting. The reason for this is that this allows everyone to implement the performance functions without being restricted to certain output type, and to allow using <code>haskey</code> to check the output.</p><h2 id="Testing-Function-Calls"><a class="docs-heading-anchor" href="#Testing-Function-Calls">Testing Function Calls</a><a id="Testing-Function-Calls-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Function-Calls" title="Permalink"></a></h2><p>We have implemented function calls to help you testing the API. There is one call for each type of calls </p><ul><li><code>test_potential_energy</code> to test potential_energy call</li><li><code>test_forces</code> to test both allocating and non-allocating force calls</li><li><code>test_virial</code> to test virial call</li></ul><p>To get these access to these functions you need to call</p><pre><code class="language-julia hljs">using AtomsCalculators.AtomsCalculatorsTesting</code></pre><p>To test our example potential <code>MyType</code> we can do</p><pre><code class="language-julia hljs">using AtomsBase
using AtomsCalculators.AtomsCalculatorsTesting

hydrogen = isolated_system([
    :H =&gt; [0, 0, 0.]u&quot;Å&quot;,
    :H =&gt; [0, 0, 1.]u&quot;Å&quot;
])

test_potential_energy(hydrogen, MyType())
test_forces(hydrogen, MyType())
test_virial(hydrogen, MyType())

test_forces(hydrogen, MyOtherType()) # this works
test_virial(hydrogen, MyOtherType()) # this will fail</code></pre><p><em>It is recommended that you use the test functions to test that your implementation supports the API fully!</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 27 October 2023 05:38">Friday 27 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
