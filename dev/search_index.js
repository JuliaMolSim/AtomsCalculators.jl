var documenterSearchIndex = {"docs":
[{"location":"interface-definition/#Interface-Definition","page":"Interface Definition","title":"Interface Definition","text":"","category":"section"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"There are two alternative ways to call the interface: using functions potential_energy, forces and virial, or using calculate function together with Energy, Forces and Virial.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Individual calls are implemented by dispatching AtomsCalculators functions","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.potential_energy for potential energy calculation\nAtomsCalculators.forces for allocating force calculation and/or...\nAtomsCalculators.forces! for non-allocating force calculation\nAtomsCalculators.virial for virial calculation","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"The calculate interface is implemented by dispatching to","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.calculate using AtomsCalculators.Energy() as the first argument for energy calculation\nAtomsCalculators.calculate using AtomsCalculators.Forces() as the first argument for forces calculaton\nAtomsCalculators.calculate using AtomsCalculators.Virial() as the first argument for virial calculation","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"You do not need to implement all of these by yourself. There is macro that will help implement the other calls. ","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Each of the individual calls have two common inputs: AtomsBase.AbstractSystem compatible structure and a calculator that incudes details of the calculation method. Calculate interface has additionally the type of calculation as the first input. You can tune calculation by passing keyword arguments, which can be ignored, but they need to be present in the function definition.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"potential_energy, forces, forces! and virial:","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"First input is AtomsBase.AbstractSystem compatible structure\nSecond input is calculator structure\nMethod has to accept keyword arguments (they can be ignored)\nNon-allocating force call force! has an AbstractVector as the first input, to which the evaluated force values are stored (look for more details below)","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"calculate:","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"First input is either Energy(), Forces() or Virial()\nSecond is AtomsBase.AbstractSystem compatible structure\nThird is calculator structure\nMethod has to accept keyword arguments (they can be ignored)","category":"page"},{"location":"interface-definition/#Output","page":"Interface Definition","title":"Output","text":"","category":"section"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Outputs for the functions need to have following properties","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Energy is a subtype of Number that has a unit with dimensions of energy (mass * length^2 / time^2)\nForce output is a subtype of AbstractVector with element type also a subtype of AbstractVector (length 3 in 3D) and unit with dimensions of force (mass * length / time^2). With additional property that it can be reinterpret as a matrix\nVirial is a square matrix (3x3 in 3D) that has units of force times length or energy\nCalculate methods return a NamedTuple that uses keys :energy, :forces and :virial to identify the results, which have the types defined above","category":"page"},{"location":"interface-definition/#Implementing-the-interface","page":"Interface Definition","title":"Implementing the interface","text":"","category":"section"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"You can either implement both of the calls e.g. for energy","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.potential_energy(system, calculator; kwargs...) and AtomsCalculators(AtomsCalculators.Energy(), system, calculator; kwargs...)","category":"page"},{"location":"interface-definition/#Example-implementations","page":"Interface Definition","title":"Example implementations","text":"","category":"section"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Example potential_energy implementation","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"using AtomsCalculators\nusing Unitful\nstruct MyType\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.potential_energy(system, calculator::Main.MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return 0.0u\"eV\"\nend","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"note: Type definition under @generate_complement macro\nYou need to use explicit definition of type when using @generate_interface macro. Main.MyType is fine MyType is not!You also need to define the type before the macro call.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Completely equivalent implementation is","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Energy, system, calculator::Main.MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return ( energy = 0.0u\"eV, )\nend","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Example virial implementation","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.@generate_interface function AtomsCalculators.virial(system, calculator::Main.MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return zeros(3,3) * u\"eV\"\nend","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Equivalent implementation is","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Virial, system, calculator::Main.MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return ( virial = zeros(3,3) * u\"eV\", )\nend","category":"page"},{"location":"interface-definition/#Implementing-forces-call","page":"Interface Definition","title":"Implementing forces call","text":"","category":"section"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Basic example","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.@generate_interface function AtomsCalculators.forces(system, calculator::Main.MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition\n    return AtomsCalculators.zero_forces(system, calculator)\nend","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"This creates both forces and forces! and calculate command with Forces() support.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.zero_forces(system, calculator) is a function that creates zero forces for a given calculator and system combo. You can use this function to tune your force output.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Same way AtomsCalculators.promote_force_type(system, calculator) creates a force type for the calculator for given input that can be used to allocate force data. You can also allocate for some other type, of your choosing or use the default one. You can overload promote_force_type for your force type, this is automatically used by zero_forces command to change the element type. If you wan to change array type overload zero_forces for your calculator.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Alternatively the definition could have been done with","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"AtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Forces, system, calculator::Main.MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition\n    return ( forces = zeros(AtomsCalculators.promote_force_type(system, calculator), length(system)), )\nend","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"or with non-allocating forces","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"struct MyOtherType\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.forces!(f::AbstractVector, system, calculator::Main.MyOtherType; kwargs...)\n    @assert length(f) == length(system)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition\n    for i in eachindex(f)\n        f[i] = zero(AtomsCalculators.promote_force_type(system, calculator))\n    end\n\n    return f\nend","category":"page"},{"location":"interface-definition/#Other-Automatically-Generated-Calls","page":"Interface Definition","title":"Other Automatically Generated Calls","text":"","category":"section"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Many methods have optimized calls when energy and forces (and/or virial) are calculated together. To allow access to these calls there are also calls","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"energy_forces for potential energy and allocating forces\nenergy_forces! for potential energy and non-allocating forces\nenergy_forces_virial for potential energy, allocating forces and virial\nenergy_forces_virial! for potential energy, non-allocating forces and virial","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"These all are generated automatically, if you have defined the corresponding individual methods. The main idea here is that you can implement more efficient methods by yourself.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Example implementation","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"function AtomsCalculators.potential_energy_forces(system, calculator::MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    E = 0.0u\"eV\"\n    f = zeros(AtomsCalculators.default_force_eltype, length(system))\n    return (;\n        :energy => E,\n        :forces => f\n    )\nend","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Defining this does not overload the corresponding non-allocating call - you need to do that separately.","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"Output for the combination methods is defined to have keys :energy, :forces and :virial. You can access them with","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"output[:energy] for energy\noutput[:forces] for forces\noutput[:virial] for viral","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"The type of the output can be NamedTuple, as was in the example above, or any structure that has the keys implemented and also supports splatting. The reason for this is that this allows everyone to implement the performance functions without being restricted to certain output type, and to allow using haskey to check the output.","category":"page"},{"location":"interface-definition/#Testing-Function-Calls","page":"Interface Definition","title":"Testing Function Calls","text":"","category":"section"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"We have implemented function calls to help you testing the API. There is one call for each type of calls ","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"test_potential_energy to test potential_energy call\ntest_forces to test both allocating and non-allocating force calls\ntest_virial to test virial call","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"To get these access to these functions you need to call","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"using AtomsCalculators.AtomsCalculatorsTesting","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"To test our example potential MyType we can do","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"using AtomsBase\nusing AtomsCalculators.AtomsCalculatorsTesting\n\nhydrogen = isolated_system([\n    :H => [0, 0, 0.]u\"Å\",\n    :H => [0, 0, 1.]u\"Å\"\n])\n\ntest_potential_energy(hydrogen, MyType())\ntest_forces(hydrogen, MyType())\ntest_virial(hydrogen, MyType())\n\ntest_forces(hydrogen, MyOtherType()) # this works\ntest_virial(hydrogen, MyOtherType()) # this will fail","category":"page"},{"location":"interface-definition/","page":"Interface Definition","title":"Interface Definition","text":"It is recommended that you use the test functions to test that your implementation supports the API fully!","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AtomsCalculators","category":"page"},{"location":"#AtomsCalculators","page":"Home","title":"AtomsCalculators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AtomsCalculators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a calculation interface for AtomsBase meant to extend the interface for calculators. At this moment this is a preliminary version with molecular dynamics and various geometry optimizations in mid. In the future there can be more functionality too.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AtomsCalculators, AtomsCalculators.AtomsCalculatorsTesting]","category":"page"},{"location":"#AtomsCalculators.@generate_interface-Tuple{Any}","page":"Home","title":"AtomsCalculators.@generate_interface","text":"@generate_interface\n\nGenerate complementary function for given function expression. This is mean to help defining the interface, so that you only need to define one of the interface methods for a given type of calculation (energy, forces, virial).\n\nExample\n\nGenerate forces! and calculate(AtomsCalculators.Forces(), ...) calls from forces definition\n\nAtomsCalculators.@generate_interface function AtomsCalculators.forces(system, calculator::Main.MyType; kwargs...)\n    #definition here\nend\n\nGenerate forces and  calculate(AtomsCalculators.Forces(), ...) calls from forces! definition\n\nAtomsCalculators.@generate_interface function AtomsCalculators.forces!(f::AbstractVector, system, calculator::Main.MyOtherType; kwargs...)\n    #definition here\nend\n\nGenerate AtomsCalculators.potential_energy call from AtomsCalculators.calculate call.\n\nAtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Energy(), system, calculator::Main.MyType; kwargs...)\n    #definition here\nend\n\nNote\n\nWhen using this macro, you need to define your calculator type completely - MyPkg.MyType is fine but MyType is not!\n\n\n\n\n\n","category":"macro"},{"location":"#AtomsCalculators.AtomsCalculatorsTesting.test_forces-Tuple{Any, Any}","page":"Home","title":"AtomsCalculators.AtomsCalculatorsTesting.test_forces","text":"test_forces(sys, calculator; force_eltype::AbstractVector=default_force_eltype, kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your forces calculation.\n\nTo use this function create a AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nforce_eltype is given for forces! interface testing. kwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#AtomsCalculators.AtomsCalculatorsTesting.test_potential_energy-Tuple{Any, Any}","page":"Home","title":"AtomsCalculators.AtomsCalculatorsTesting.test_potential_energy","text":"test_potential_energy(sys, calculator; kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your potential energy calculation.\n\nTo use this function create an AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nkwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#AtomsCalculators.AtomsCalculatorsTesting.test_virial-Tuple{Any, Any}","page":"Home","title":"AtomsCalculators.AtomsCalculatorsTesting.test_virial","text":"test_virial(sys, calculator; kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your virial calculation.\n\nTo use this function create an AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nkwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"}]
}
