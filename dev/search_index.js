var documenterSearchIndex = {"docs":
[{"location":"api/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/","page":"Index","title":"Index","text":"Modules = [AtomsCalculators, AtomsCalculators.AtomsCalculatorsTesting, AtomsCalculators.Testing]","category":"page"},{"location":"api/#AtomsCalculators.Energy","page":"Index","title":"AtomsCalculators.Energy","text":"Energy : a calculate property to calculate the potential energy\n\n\n\n\n\n","category":"type"},{"location":"api/#AtomsCalculators.Forces","page":"Index","title":"AtomsCalculators.Forces","text":"Forces : a calculate property to calculate the forces\n\n\n\n\n\n","category":"type"},{"location":"api/#AtomsCalculators.Virial","page":"Index","title":"AtomsCalculators.Virial","text":"Virial : a calculate property to calculate the virial \n\n\n\n\n\n","category":"type"},{"location":"api/#AtomsCalculators._fltype-Tuple{Any}","page":"Index","title":"AtomsCalculators._fltype","text":"_fltype(system) : floating point type used by the calculator\n\nThis is an internal helper function and not considered part of the public API. \n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.calculate","page":"Index","title":"AtomsCalculators.calculate","text":"calculate(properties, sys, calc; kwargs...) -> NamedTuple\n\n\n\n\n\n","category":"function"},{"location":"api/#AtomsCalculators.energy_forces!-Tuple{AbstractVector, Any, Any}","page":"Index","title":"AtomsCalculators.energy_forces!","text":"energy_forces!(f, system, calculator; kwargs...) -> NamedTuple\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.energy_forces-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.energy_forces","text":"energy_forces(system, calculator; kwargs...) -> NamedTuple\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.energy_forces_virial!-Tuple{AbstractVector, Any, Any}","page":"Index","title":"AtomsCalculators.energy_forces_virial!","text":"energy_forces_virial!(f, system, calculator; kwargs...) -> NamedTuple\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.energy_forces_virial-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.energy_forces_virial","text":"energy_forces_virial(system, calculator; kwargs...) -> NamedTuple\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.energy_unit","page":"Index","title":"AtomsCalculators.energy_unit","text":"energy_unit(calc) : energy unit used by the calculator\n\n\n\n\n\n","category":"function"},{"location":"api/#AtomsCalculators.force_unit-Tuple{Any}","page":"Index","title":"AtomsCalculators.force_unit","text":"force_unit(calc) : force unit returned by the calculator\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.forces","page":"Index","title":"AtomsCalculators.forces","text":"forces(sys, calc; kwargs...)::AbstractVector{SVector{D, Unitful.Force}}\n\n\n\n\n\n","category":"function"},{"location":"api/#AtomsCalculators.forces!","page":"Index","title":"AtomsCalculators.forces!","text":"forces(frc, sys, calc; kwargs...) -> frc\n\n\n\n\n\n","category":"function"},{"location":"api/#AtomsCalculators.get_parameters-Tuple{Any}","page":"Index","title":"AtomsCalculators.get_parameters","text":"get_parameters(calc) -> NamedTuple or ComponentArray\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.get_state-Tuple{Any}","page":"Index","title":"AtomsCalculators.get_state","text":"get_state(calc) -> NamedTuple or ComponentArray\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.length_unit","page":"Index","title":"AtomsCalculators.length_unit","text":"length_unit(calc) : length unit assumed and used by the calculator \n\n\n\n\n\n","category":"function"},{"location":"api/#AtomsCalculators.potential_energy","page":"Index","title":"AtomsCalculators.potential_energy","text":"potential_energy(sys, calc; kwargs...)::Unitful.Energy\n\n\n\n\n\n","category":"function"},{"location":"api/#AtomsCalculators.promote_force_type-Union{Tuple{D}, Tuple{AtomsBase.AbstractSystem{D}, Any}} where D","page":"Index","title":"AtomsCalculators.promote_force_type","text":"promote_force_type(system, calc) : force type (float type and unit) returned  by the calculator\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.set_parameters!-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.set_parameters!","text":"set_parameters!(calc, parameters) -> calc_new\n\nThe returned calc_new may be a mutated calc or a new object. The caller  should not assume that calc_new is the same object as calc. This allows  for non-mutating implementations of set_parameters!.\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.set_state!-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.set_state!","text":"set_state!(calc, state) -> calc_new\n\nThe returned calc_new may be a mutated calc or a new object. The caller  should not assume that calc_new is the same object as calc. This allows  for non-mutating implementations of set_state!.\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.virial","page":"Index","title":"AtomsCalculators.virial","text":"virial(sys, calc; kwargs...)::SMatrix{3,3,<:Unitful.Energy}\n\n\n\n\n\n","category":"function"},{"location":"api/#AtomsCalculators.zero_energy-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.zero_energy","text":"zero_energy(system, calc) : initialize a zero energy value \n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.zero_forces-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.zero_forces","text":"zero_forces(system, calc) : allocate a zero forces array\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.zero_virial-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.zero_virial","text":"zero_virial(system, calc) : initialize a zero virial matrix \n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.@generate_interface-Tuple{Any}","page":"Index","title":"AtomsCalculators.@generate_interface","text":"@generate_interface\n\nGenerate complementary function for given function expression. This is mean to help defining the interface, so that you only need to define one of the interface methods for a given type of calculation (energy, forces, virial).\n\nExample\n\nGenerate forces! and calculate(AtomsCalculators.Forces(), ...) calls from forces definition\n\nAtomsCalculators.@generate_interface function AtomsCalculators.forces(system, calculator::MyType; kwargs...)\n    #definition here\nend\n\nGenerate forces and  calculate(AtomsCalculators.Forces(), ...) calls from forces! definition\n\nAtomsCalculators.@generate_interface function AtomsCalculators.forces!(f::AbstractVector, system, calculator::MyOtherType; kwargs...)\n    #definition here\nend\n\nGenerate AtomsCalculators.potential_energy call from AtomsCalculators.calculate call.\n\nAtomsCalculators.@generate_interface function AtomsCalculators.calculate(::AtomsCalculators.Energy(), system, calculator::MyType; kwargs...)\n    #definition here\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#AtomsCalculators.Testing.test_energy_forces-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.Testing.test_energy_forces","text":"test_energy_forces(sys, calculator; force_eltype=nothing, rtol=1e-8, kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your calculator implements energy and forces interfaces correctly.\n\nTo use this function create a AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nforce_eltype can be given to forces! interface testing. Default promote_force_type. rtol can be given to control error in comparisons. kwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.Testing.test_energy_forces_virial-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.Testing.test_energy_forces_virial","text":"test_energy_forces_virial(sys, calculator; force_eltype=nothing, rtol=1e-8, kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your calculator implements energy, forces and virial interfaces correctly.\n\nTo use this function create a AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nforce_eltype can be given to forces! interface testing. Default promote_force_type. rtol can be given to control error in comparisons. kwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.Testing.test_forces-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.Testing.test_forces","text":"test_forces(sys, calculator; force_eltype::AbstractVector=default_force_eltype, rtol=1e-8, kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your forces calculation implementation works correctly.\n\nTo use this function create a AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nforce_eltype can be given to forces! interface testing. Default promote_force_type. rtol can be given to control error in comparisons. kwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.Testing.test_potential_energy-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.Testing.test_potential_energy","text":"test_potential_energy(sys, calculator; rtol=1e-8, kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your potential energy calculation implementation works correctly.\n\nTo use this function create an AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nrtol can be given to control error in comparisons. kwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AtomsCalculators.Testing.test_virial-Tuple{Any, Any}","page":"Index","title":"AtomsCalculators.Testing.test_virial","text":"test_virial(sys, calculator; kwargs...)\n\nTest your calculator for AtomsCalculators interface. Passing test means that your virial calculation implementation works correctly.\n\nTo use this function create an AtomsBase system sys and a calculator for your own calculator. Test function will then call the interface and performs checks for the output and checks that random keywords are accepted in input. \n\nkwargs can be passed to the calculator for tuning during testing.\n\nThe calculator is expected to work without kwargs.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = AtomsCalculators","category":"page"},{"location":"interface/#Interface-Definition","page":"Interface","title":"Interface Definition","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The AtomsCalculator interface is designed to provide easy to use and easy to read high level functions for standard molecular mechanics, while at the same time being flexible and extensible. Moreover the flexible low-level interface is designed to be compatible with Lux.jl to enable training of parameterized models. Due to this tension (ease of use vs flexibility) there are two alternative ways to call and implement the interface, which are described in separate sections below. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"A new calculator need not implement the entire interface, or indeed both interfaces to be useful. Moreover, AtomsCalculators provides various utilities to help with the implementation.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Most interface functions have two common inputs: an AtomsBase.AbstractSystem{D} compatible structure and a \"calculator\" that specifies details of the calculation method. Throughout this documentation: ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"sys : always specifies a system, usually an AtomsBase.AbstractSystem{D}\ncalc : always specifies a calculator implementing (part of) the AtomsCalculators interface. ","category":"page"},{"location":"interface/#highlevelinterface","page":"Interface","title":"High-Level Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The high-level interface provides function prototypes for potential energy, forces and virial calculations.","category":"page"},{"location":"interface/#Minimal-high-level-interface","page":"Interface","title":"Minimal high-level interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"A minimal implementation of an AtomsCalculators calculator should provide (however, see alternatives below)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"energy_unit(calc) : return energy unit used by the calculator\nlength_unit(calc) : return length unit used by the calculator\npotential_energy(sys, calc; kwargs...) : return potential energy of the system as a Unitful.Energy\nforces(sys, calc; kwargs...) return forces as an AbstractVector{SVector{D, <: Unitful.Force}}\nvirial(sys, calc; kwargs...) return virial (not stress!) as a SMatrix{D, D, Unitful.Energy}","category":"page"},{"location":"interface/#Remarks","page":"Interface","title":"Remarks","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Methods must accept keyword arguments, but they can be ignored. For a discussion of some standard keyword arguments that a calculator may wish to support see Reserved Keyword Arguments. \nIf a calculator does not implement a function, then it can simply choose not to provide that method. A simulator that relies on that function will then simply fail. For example a QM/MM force mixing scheme may be unable to provide potential_energy. ","category":"page"},{"location":"interface/#Extended-high-level-interface","page":"Interface","title":"Extended high-level interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The extended interface can be automatically generated from the minimal interface, but for various reasons (in particular performance), some calculators may prefer to implement their own methods for the following functions.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Several utility functions are derived from energy_unit and length_unit which can be overloaded by a calculator implementation: ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"force_unit(calc) : compute force unit (default from energy and length units)\npromote_force_type(sys, calc) : determine type of force\nzero_energy(sys, calc) : initialize potential energy \nzero_forces(sys, calc) : initilize a force vector \nzero_virial(sys, calc) : initialize a virial matrix ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"A calculator may provide non-allocating and or combined calculations that can sometimes be preferred for performance reasons. All of these return results as a NamedTuple.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"energy_forces(sys, calc)\nenergy_forces!(f, sys, calc)\nenergy_forces_virial(sys, calc)\nenergy_forces_virial!(f, sys, calc)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"To avoid writing too much boiler-plate code to support the full interface, see the utilities section of the docs. ","category":"page"},{"location":"interface/#Low-Level-Interface","page":"Interface","title":"Low-Level Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All high-level functionality listed above can also be accessed via \"low-level\" calls with user-specifiable parameters through calculate methods. The low-level calculate interface follows the Lux model for parameters and state. This means that when calculations are performed with the calculate interface calculators must act as immutable structs that are passed  to the calculate function together with parameters and state. All calculations then return an output and a state. Note, we only require calculators act immutable but not to be technically immutable. For example the same calculator can implement the high-level interface and then mutate an internal state.","category":"page"},{"location":"interface/#General-structure-of-the-low-level-interface","page":"Interface","title":"General structure of the low-level interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The low level interface is built around a calculate function ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"calculate(property, sys, calc, ps, st; kwargs...)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"where,","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"property is the property to be computed e.g. PotentialEnergy(),\nsys is an system, \ncalc is a calculator, \nps either nothing or a nested NamedTuple storing the calculator parameters,\nst either nothing or a nested NamedTuple storing the calculator state\nkwargs... must be allowed but can be ignored; with caveats - see Reserved Keyword Arguments","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Irrespective of which property is required, the return type is always a NamedTuple with keys indicating the name of properties being computed. The content of this NamedTuple is not required to be restricted to the requested property (or, properties - more on this below). ","category":"page"},{"location":"interface/#Calculator-State-and-Parameters","page":"Interface","title":"Calculator State and Parameters","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"To manage parameters and state, AtomsCalculators provides prototypes that can be overloaded:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"get_state(calc) : return a NamedTuple or ComponentArray containing the entire mutable state of the calculator;\nset_state!(calc, st) : set the state of the calculator, may be mutating or non-mutating;\nget_parameters(calc) : return a NamedTuple or ComponentArray containing all parameters;\nset_parameters!(calc, ps) : set the parameters of the calculator, may be mutating or non-mutating.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"This functionality is somewhat separate from Lux","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"ps, st = Lux.setup(rng, model)\nps = LuxCore.initparameters(rng, model)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The difference is that Lux.setup initializes parameters, whereas, *_state and *_parameters is intended to read and write existing (already fitted) parameters.  In addition, a calculator need not implement LuxCore.initparams and LuxCore.initstate, but it has the option to do so.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The default implementations for *_state and *_parameters assume a stateless and parameter-free calculator.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The calls set_state! and set_parameters! may be mutating (hence the !) but need not be mutating. The correct usage is therefore ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"new_calc = set_state!(calc, st) \nnew_calc = set_parameters!(calc, ps)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In general, the caller should not assume that new_calc and calc are references to the same object.","category":"page"},{"location":"interface/#Molecular-mechanics-with-the-low-level-interface","page":"Interface","title":"Molecular mechanics with the low-level interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The three basic properties to perform molecular mechanics simulations are energy, forces and virials, defined through","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Energy()\nForces()\nVirial()","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"With these properties, the following calling conventions are analogous: ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"calculate(Energy(), sys, calc, ps, st) is analogous to potential_energy(sys, calc)\ncalculate(Forces(), sys, calc, ps, st) is analogous to forces(sys, calc)\ncalculate(Virial(), sys, calc, ps, st) is analogous to virial(sys, calc)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Energies, forces and virials can be obtained from the output NamedTuple via ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"out = calculate(Energy(), sys, calc, ps, st)\nout.energy \nout = calculate(Forces(), sys, calc, ps, st)\nout.forces\nout = calculate(Virial(), sys, calc, ps, st)\nout.virial ","category":"page"},{"location":"interface/#Multiple-properties","page":"Interface","title":"Multiple properties","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Multiple properties can be requested from a calculator by bundling them into a tuple. For example, ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"efv = calculate( (Energy(), Forces(), Virial()), sys, calc, ps, st)\nefv.energy \nefv.forces \nefv.virial ","category":"page"},{"location":"interface/#Extensions","page":"Interface","title":"Extensions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"A calculator can extend the calculate interface without having to make a pull request to AtomsCalculators. For example, a site potential could supply the possibility of returning site energies, which could be implemented as follows. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"struct SiteEnergies end \nout = calculate(SiteEnergies(), sys, calc, ps, st)\nout.siteenergies::AbstractVector{<: Unitful.Energy}","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"If such an extension could be of value to a broader developer or user base, then an issue and/or PR to AtomsCalculators would be very welcome. ","category":"page"},{"location":"interface/#keywordargs","page":"Interface","title":"Recommended Keyword Arguments","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The following keyword arguments are used consistently throughout the AtomsBase / AtomsCalculators ecosystem. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"domain : the domain over which to evaluate an energy, normally used for site potentials where partial energies can be evaluated. Calculators that do not provide this functionality may wish to throw an error is a partial energy is requested to avoid silent bugs. \nexecutor : a label or type specifying how to execute the calculator (e.g. in serial, multi-threaded, distributed)\nnlist : a possibly precomputed neighbourlist","category":"page"},{"location":"intdocback/#Previous-Version-of-Interface-Docs","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"","category":"section"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"There are two alternative ways to call the interface: using functions potential_energy, forces and virial, or using calculate function together with Energy, Forces and Virial.","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"Individual calls are implemented by dispatching AtomsCalculators functions","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"AtomsCalculators.potential_energy for potential energy calculation\nAtomsCalculators.forces for allocating force calculation and/or...\nAtomsCalculators.forces! for non-allocating force calculation\nAtomsCalculators.virial for virial calculation","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"The calculate interface is implemented by dispatching to","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"AtomsCalculators.calculate using AtomsCalculators.Energy() as the first argument for energy calculation\nAtomsCalculators.calculate using AtomsCalculators.Forces() as the first argument for forces calculaton\nAtomsCalculators.calculate using AtomsCalculators.Virial() as the first argument for virial calculation","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"You do not need to implement all of these by yourself. There is macro that will help implement the other calls. ","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"Each of the individual calls have two common inputs: AtomsBase.AbstractSystem compatible structure and a calculator that incudes details of the calculation method. Calculate interface has additionally the type of calculation as the first input. You can tune calculation by passing keyword arguments, which can be ignored, but they need to be present in the function definition.","category":"page"},{"location":"intdocback/#High-level-vs-Low-level-Interface","page":"Previous Version of Interface Docs","title":"High-level vs Low-level Interface","text":"","category":"section"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"The philosophy behing AtomsCalculators.jl is to provide high-level calls with default  parameters through potential_energy, forces, forces! and virial and low-level calls  with user-specifiable parameters through calculate. ","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"The low-level calculate interface follows the Lux model for parameters and state. This means that calculators are immutable structs that are passed  to the calculate function together with parameters and state. All calculations then return  an output and a state.","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"When implementing a new calculator, two paths can be chosen:","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"Providing a full low level implementation  In this setup, one implements calculate for the various type of   calculations to be supported, with full handling of parameters and state. On top of that,   one should provide sensible defaults for calls with parameters and state set to nothing.   These will be used to generate the high-level calls.\nOnly implementing high-level calls  In this case, one only implements the high-level potential_energy, forces and virial   (or some of them). Appropriate low-level implementation for calculate is then automatically   generated by using and returning dummy state and parameters set to nothing.","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"Note that when using the high-level approach, fixed parameters are allowed to be bundled inside the calculator.","category":"page"},{"location":"intdocback/#Method-Signatures","page":"Previous Version of Interface Docs","title":"Method Signatures","text":"","category":"section"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"potential_energy, forces, forces! and virial:","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"First input is AtomsBase.AbstractSystem compatible structure\nSecond input is calculator structure\nMethod has to accept keyword arguments (they can be ignored)\nNon-allocating force call force! has an AbstractVector as the first input, to which the evaluated force values are stored (look for more details below)","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"calculate:","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"First input is either Energy(), Forces() or Virial()\nSecond is AtomsBase.AbstractSystem compatible structure\nThird is calculator structure\nFourth is parameters\nFifth is state\nMethod has to accept keyword arguments (they can be ignored)","category":"page"},{"location":"intdocback/#Output","page":"Previous Version of Interface Docs","title":"Output","text":"","category":"section"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"Outputs for the functions need to have following properties","category":"page"},{"location":"intdocback/","page":"Previous Version of Interface Docs","title":"Previous Version of Interface Docs","text":"Energy is a subtype of Number that has a unit with dimensions of energy (mass * length^2 / time^2)\nForce output is a subtype of AbstractVector with element type also a subtype of AbstractVector (length 3 in 3D) and unit with dimensions of force (mass * length / time^2). With additional property that it can be reinterpret as a matrix\nVirial is a square matrix (3x3 in 3D) that has units of force times length or energy\nCalculate methods return a NamedTuple that uses keys :energy, :forces and :virial to identify the results, which have the types defined above, and additionally returns the updated :state.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = AtomsCalculators","category":"page"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The main AtomsCalculators packgage has utilities that help creating calculators and testing functions that help to test that your calculator implement the interface correctly.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"In additionally there is AtomsCalculatorsUtilities package that has utility calculators and other helpful utilities.","category":"page"},{"location":"utilities/#Interface-generating-macro","page":"Utilities","title":"Interface generating macro","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"AtomsCalculator provide a macro @generate_interface that generate other interfaces from the input.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"In example, if you only provide high level interface you can just implement","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"AtomsCalculators.@generate_interface function AtomsCalculators.forces(\n    sys,\n    calc::MyCalc;\n    kwords...\n)\n   #definition\nend","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This also creates low level calls for your calculator and also non-allocating high level call. So, you will get:","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The call you implemented - here high level forces call\nNon-allocating forces! call\nLow level calculate(::Forces(), sys, calc::MyCalc, ps=nothing, st=nothing; kwargs...)","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"You would get the same calls generated, if you defined any of the above calls and wrapped it in the macro. Thus all of the following produce the same interface","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"AtomsCalculators.@generate_interface function AtomsCalculators.forces(\n    sys,\n    calc::MyCalc; \n    kwords...\n)\n   #definition\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.forces!(\n    f, \n    sys, \n    calc::MyCalc; \n    kwords...\n)\n   #definition\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.calculate(\n    ::AtomsCalculators.Force,\n    sys,\n    calc::MyCalc,\n    ps=nothing,\n    st=nothing;\n    kwords...\n)\n   #definition\nend","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"and you only need to define one of them.","category":"page"},{"location":"utilities/#Example-macro-use","page":"Utilities","title":"Example macro use","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"To implement complite interface by only defining high level call you can define","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"AtomsCalculators.@generate_interface function AtomsCalculators.potential_energy(\n    sys,\n    calc::MyCalc; \n    kwords...\n)\n   #definition\nend\n\n# or alternatively forces! call\nAtomsCalculators.@generate_interface function AtomsCalculators.forces(\n    sys,\n    calc::MyCalc; \n    kwords...\n)\n   #definition\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.virial(\n    sys,\n    calc::MyCalc; \n    kwords...\n)\n   #definition\nend","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"With low level call you can implement","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"AtomsCalculators.@generate_interface function AtomsCalculators.calculate(\n    ::AtomsCalculators.Energy,\n    sys,\n    calc::MyCalc,\n    ps=nothing,\n    st=nothing;\n    kwords...\n)\n   #definition\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.calculate(\n    ::AtomsCalculators.Force,\n    sys,\n    calc::MyCalc,\n    ps=nothing,\n    st=nothing;\n    kwords...\n)\n   #definition\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.calculate(\n    ::AtomsCalculators.Virial,\n    sys,\n    calc::MyCalc,\n    ps=nothing,\n    st=nothing;\n    kwords...\n)\n   #definition\nend\n","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Both of these methods create fully working implementation.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = AtomsCalculators.Testing","category":"page"},{"location":"utilities/#Testing-functions","page":"Utilities","title":"Testing functions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"AtomsCalculators has a submodule Testing that includes testing functions","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"test_potential_energy(sys, calc) that test the interface for potential energy calculation\ntest_forces(sys, calc) that test the interface for forces calculation\ntest_virial(sys, calc) that test the interface for forces calculation","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"There is also test functions that combine the above calls","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"test_energy_forces(sys, calc) that test the interface for potential energy and forces\ntest_energy_forces_virial(sys, calc) that test the interface for potential energy, forces and virial","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"It is recommended to use appropriate combined call, if your calculator has implemented more than one of the methods.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Passing the testing set confirms that your calculator implements the interface correctly.","category":"page"},{"location":"utilities/#Testing-example","page":"Utilities","title":"Testing example","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"using AtomsCalculators.Testing\n\nsys = # create/load a AtomsBase system structure, which the calculator is expected to calculate\nmycalc = # Create your calculator\n\n# Test potential energy calculation\ntest_potential_energy(sys, mycalc)\n# Test forces calculation\ntest_forces(sys, calc)\n\n# Same as the two above commands together\ntest_energy_forces(sys, calc)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AtomsCalculators","category":"page"},{"location":"#AtomsCalculators","page":"Home","title":"AtomsCalculators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AtomsCalculators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package specifies the calculation interface for the AtomsBase ecosystem. At this moment it provides a first version of a molecular mechanics interface (energy, forces, virial). Suggestions for extensions are welcome. ","category":"page"},{"location":"example/#Implementing-the-interface","page":"Example","title":"Implementing the interface","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Note, this section is partly outdated!","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"You can either implement both of the calls e.g. for energy","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AtomsCalculators.potential_energy(system, calculator; kwargs...) and AtomsCalculators.calculate(AtomsCalculators.Energy(), system, calculator, ps=nothing, st=nothing; kwargs...)","category":"page"},{"location":"example/#Example-implementations","page":"Example","title":"Example implementations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Example potential_energy implementation","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using AtomsCalculators\nusing Unitful\nstruct MyType\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.potential_energy(system, calculator::MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return 0.0u\"eV\"\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Completely equivalent implementation is","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AtomsCalculators.@generate_interface function AtomsCalculators.calculate(\n    ::AtomsCalculators.Energy, \n    system, \n    calculator::MyType,\n    ps=nothing,\n    st=nothing; \n    kwargs...\n)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return ( energy = 0.0u\"eV, )\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Example virial implementation","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AtomsCalculators.@generate_interface function AtomsCalculators.virial(system, calculator::MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return zeros(3,3) * u\"eV\"\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Equivalent implementation is","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AtomsCalculators.@generate_interface function AtomsCalculators.calculate(\n    ::AtomsCalculators.Virial, \n    system, \n    calculator::MyType,\n    ps=nothing,\n    st=nothing;\n    kwargs...\n)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    return ( virial = zeros(3,3) * u\"eV\", state=nothing)\nend","category":"page"},{"location":"example/#Implementing-forces-call","page":"Example","title":"Implementing forces call","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Basic example","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AtomsCalculators.@generate_interface function AtomsCalculators.forces(system, calculator::MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition\n    return AtomsCalculators.zero_forces(system, calculator)\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This creates both forces and forces! and calculate command with Forces() support.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AtomsCalculators.zero_forces(system, calculator) is a function that creates zero forces for a given calculator and system combo. You can use this function to tune your force output.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Same way AtomsCalculators.promote_force_type(system, calculator) creates a force type for the calculator for given input that can be used to allocate force data. You can also allocate for some other type, of your choosing or use the default one. You can overload promote_force_type for your force type, this is automatically used by zero_forces command to change the element type. If you wan to change array type overload zero_forces for your calculator.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Alternatively the definition could have been done with","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AtomsCalculators.@generate_interface function AtomsCalculators.calculate(\n    ::AtomsCalculators.Forces, \n    system, \n    calculator::MyType,\n    ps=nothing,\n    st=nothing;\n    kwargs...\n)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition\n    return ( forces = zeros(AtomsCalculators.promote_force_type(system, calculator), length(system)), state=nothing )\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"or with non-allocating forces","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"struct MyOtherType\nend\n\nAtomsCalculators.@generate_interface function AtomsCalculators.forces!(f::AbstractVector, system, calculator::MyOtherType; kwargs...)\n    @assert length(f) == length(system)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition\n    for i in eachindex(f)\n        # forces! adds to the force array\n        f[i] += zero(AtomsCalculators.promote_force_type(system, calculator))\n    end\n\n    return f\nend","category":"page"},{"location":"example/#Other-Automatically-Generated-Calls","page":"Example","title":"Other Automatically Generated Calls","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Many methods have optimized calls when energy and forces (and/or virial) are calculated together. To allow access to these calls there are also calls","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"energy_forces for potential energy and allocating forces\nenergy_forces! for potential energy and non-allocating forces\nenergy_forces_virial for potential energy, allocating forces and virial\nenergy_forces_virial! for potential energy, non-allocating forces and virial","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"These all are generated automatically, if you have defined the corresponding individual methods. The main idea here is that you can implement more efficient methods by yourself.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Example implementation","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"function AtomsCalculators.potential_energy_forces(system, calculator::MyType; kwargs...)\n    # we can ignore kwargs... or use them to tune the calculation\n    # or give extra information like pairlist\n\n    # add your own definition here\n    E = 0.0u\"eV\"\n    f = zeros(AtomsCalculators.default_force_eltype, length(system))\n    return (;\n        :energy => E,\n        :forces => f\n    )\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Defining this does not overload the corresponding non-allocating call - you need to do that separately.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Output for the combination methods is defined to have keys :energy, :forces and :virial. You can access them with","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"output[:energy] for energy\noutput[:forces] for forces\noutput[:virial] for viral","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The type of the output can be NamedTuple, as was in the example above, or any structure that has the keys implemented and also supports splatting. The reason for this is that this allows everyone to implement the performance functions without being restricted to certain output type, and to allow using haskey to check the output.","category":"page"},{"location":"example/#Testing-Function-Calls","page":"Example","title":"Testing Function Calls","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"We have implemented function calls to help you testing the API. There is one call for each type of calls","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"test_potential_energy to test potential_energy call\ntest_forces to test both allocating and non-allocating force calls\ntest_virial to test virial call\ntest_energy_forces to test both potential energy and force calls\ntest_energy_forces_virial to test everything ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To get these access to these functions you need to call","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using AtomsCalculators.AtomsCalculatorsTesting","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To test our example potential MyType we can do","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using AtomsBase\nusing AtomsCalculators.AtomsCalculatorsTesting\n\nhydrogen = isolated_system([\n    :H => [0, 0, 0.]u\"Å\",\n    :H => [0, 0, 1.]u\"Å\"\n])\n\ntest_potential_energy(hydrogen, MyType())\ntest_forces(hydrogen, MyType())\ntest_virial(hydrogen, MyType())\n\ntest_forces(hydrogen, MyOtherType()) # this works\ntest_virial(hydrogen, MyOtherType()) # this will fail\n\n# If you have energy and forces implemented use this over others\ntest_energy_forces(hydrogen, MyType())\n\n# If you have energy, forces and virial implemented use this others\ntest_energy_forces_virial(hydrogen, MyType())","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"It is recommended that you use the test functions to test that your implementation supports the API fully!","category":"page"}]
}
