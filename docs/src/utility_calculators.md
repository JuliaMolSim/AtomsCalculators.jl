# Utility calculators

We supply special calculators that can be used to alter input 

All of these calculators are defined in submodule [UtilityCalculators](@ref). To use them just add

```julia
using AtomsCalculators.UtilityCalculators
```

## Combination Calculator

[CombinationCalculator](@ref) can be used to combine separate calculators to a single calculator. This is usful when results of several calculators are added together.

Here are couple of ways to create CombinationCalculator

```julia
CombinationCalculator(calc1, calc2)
CombinationCalculator(calc1, calc2, calc3...)
CombinationCalculator(calc1, calc2; multithreading=true)
```

By default multithreading is off, but giving kword `multithreading=true` toggles it on. This means that all calculators are launched at the same time.

[CombinationCalculator](@ref) has an additional feature that allows it to edit what keywords are passed down on the calculators. This allows e.g. generating data that can be used by all the calculators.

The default is passing keywords as they are. There are two ways to change this, fist is global setting with [generate_keywords](@ref) function or by givin keyword `keywordgenerator`. Global option is intended e.g. for package authors to make global settings. You could e.g. use it to calculate pair list for pair potentials:

```julia
function AtomsCalculators.UntilityCalculators.generate_keywords(
    sys, 
    pp::PairPotential...; 
    kwargs...
)
    cutoff = cutoff_radius(pp[begin])
    if all( c ->  cutoff_radius(c) â‰ˆ cutoff, pp )
        plist = PairList(sys, cutoff)
        return (; :plist => plist, kwargs...)
    else
        return kwargs
    end
end
```

PairPotential author could have this in his package and it would set it globally.

`keyword_generator` keyword allows you to set keywords for individual `CombinationCalculator`. 

```julia
function remove_keywords(sys, pp...; kwargs...)
    return (; )
end

CombinationCalculator(calc1, calc2; keyword_generator=remove_keywords)
```


## Reporting Calculator

[ReportingCalculator](@ref) is used to collect information during calculation. To do this ReportingCalculator call a function to generate a message and then passes that message to a `Channel`.

By default message is generated by a function [generate_message](@ref), but this can be changed by giving a keyword `message_function`. The default message is the value of latest calculation

```julia
c = Channel(32)
rep_calc = ReportingCalculator(calc, c)

e = AtomsCalculators.potential_energy(system, rep_calc)
e == fetch(c)         # true
e == take!(rep_calc)  # true
```

You can call `fetch` and `take!` directly to [ReportingCalculator](@ref) to access the `Channel`. 

```julia
function my_message(sys, calc, e::Number; kwords...)
    return FlexibleSystem(sys; energy=e)
end

rep_calc = ReportingCalculator(calc, Channel(32); message_function=my_message)

f = AtomsCalculators.forces(system, rep_calc)  # no message generated
e = AtomsCalculators.potential_energy(system, rep_calc) # message generated
```


## Subsystem Calculator

[SubSystemCalculator](@ref) is used to split input system into smaller parts. This is useful e.g. for QM/MM calculations.

To use [SubSystemCalculator](@ref) you need to give an other calculator and indexes that define subsystem. E.g., if your subsystem is defined by atoms 1 to 10 and 15 you can create subsystem calculator by

```julia
sub_calc = SubSystemCalculator( mycalc, [1:10..., 15])
```

This calculator will then create a system with atoms 1 to 10 and 15 and pass that one into the calculator. Zero forces are given to all other atoms.
